## Ejercicio 1 - (50 puntos)

Se desea construir un sistema similar al del taller que debe ejecutar concurrentemente 5 tareas independientes. 

Las tareas de este sistema utilizarán el registro `ecx` como reservado el cual al ser un registro de la tarea, este puede ser modificado y seteado en cualquier momento. 

El registro `ecx` contendrá en todo momento un número de ticks del reloj denominado UTC (Unreal Time Clock) el cual será actualizado por el sistema, incrementándolo cada vez que la tarea vuelva a ser ejecutada luego de una interrupción de reloj. 

Tener en cuenta que este valor solo esta guardado en un único lugar que se corresponde siempre con el espacio dedicado a los `ecx` de cada tarea.

Por otro lado, el sistema cuenta además con el servicio *fuiLlamadaMasVeces* que permite que una tarea pregunte si el UTC de otra tarea es menor que el suyo. 

Este servicio espera en `edi` el `ID` de la tarea por la que se esta preguntando (los `IDs` van del $0$ al $4$) y devuelve el resultado en `eax`. 

El resultado será $0$ si la tarea llamadora tiene un UTC menor o igual que la tarea por la que preguntó y $1$ en caso contrario.

### $(a)$ Describir qué entradas están presentes en la `GDT` indicando los campos que consideren relevantes.

**Segmentos de Código y Datos**: Cada tarea requiere segmentos de código y datos, cada uno con un descriptor que define el acceso y los límites de cada segmento.
- **Código (CPL = 3)**: Segmento de código con privilegio de usuario (CPL=3) para cada tarea, permitiendo que cada tarea tenga su propio contexto de ejecución en modo usuario.
- **Datos (CPL = 3)**: Segmento de datos con privilegio de usuario para cada tarea, que proporciona acceso a las variables y estructuras de datos de cada tarea.

**Segmento de TSS para Cada Tarea**: Una entrada en la GDT para cada TSS de las 5 tareas.
- **`Base`**: Indica la dirección base donde se encuentra la TSS de cada tarea en la memoria.
- **`Limit`**: Define el tamaño de la TSS.
- **Tipo de Descriptor**: El tipo de descriptor se configura para que indique que esta entrada es un TSS de 32 bits.
- **`DPL`**: Se establece en 0 para asegurar que solo el kernel pueda acceder directamente a estas TSS.

Cada TSS permitirá almacenar el valor de `ecx` que representa el **UTC** y el resto de los registros y datos de contexto de cada tarea, actualizándolos cuando el sistema realiza un cambio de contexto.

### $(b)$ Describir qué deben modificar respecto del sistema del taller para que el valor UTC se actualice correctamente en los `ecx` de cada tarea.

Para actualizar el valor de UTC en el registro `ecx` de cada tarea, el sistema debe:

**Guardar el `ecx` de Cada Tarea en la TSS Correspondiente**: Como el valor de UTC de cada tarea se guarda en su propio `ecx`, el sistema debe almacenar `ecx` en la TSS de cada tarea cuando se hace un cambio de contexto. 

De esta manera, cada vez que se realiza un cambio de contexto, el valor de `ecx` actual se mantiene y se actualiza para cada tarea.

**Incrementar `ecx` en Cada Cambio de Contexto**:
- Durante el **manejo de la interrupción del reloj**, el scheduler debe:
- Recuperar el valor de `ecx` de la TSS de la tarea que será ejecutada.
- Incrementar `ecx` en `1`.
- Guardar el nuevo valor de `ecx` en la TSS antes de pasar el control a la tarea.

Esta modificación garantiza que `ecx` de cada tarea refleje el UTC, incrementándose cada vez que la tarea es ejecutada luego de una interrupción de reloj.

### $(c)$ Describir qué y cómo deben modificar el sistema del taller para poder implementar el servicio *fuiLlamadaMasVeces*.

Para implementar el servicio *fuiLlamadaMasVeces*, el sistema debe:

**Acceder al UTC (`ecx`) de Cada Tarea**:
- Como el UTC está en el registro `ecx` en la TSS de cada tarea, se debe consultar el valor de `ecx` de la tarea solicitada (almacenado en la TSS correspondiente).
- La función debe recibir el ID de la tarea de la cual se desea consultar el UTC, y buscar el valor de `ecx` en la TSS correspondiente.

**Comparar los Valores de UTC (`ecx`)**:
- Comparar el valor de `ecx` de la tarea actual (la llamadora) con el valor de `ecx` de la tarea especificada en `edi`.
- Si el valor de `ecx` de la tarea actual es mayor o igual, el servicio devolverá `0` en `eax`.
- En caso contrario, devolverá `1`.

- Agregar una interrupción o syscall que permita a cualquier tarea invocar el servicio *fuiLlamadaMasVeces* desde el espacio de usuario.
- Configurar un número de syscall (o interrupción) específico para este servicio y asignar el manejador correspondiente en el IDT.

### $(d)$ Implementar el servicio *fuiLlamadaMasVeces* usando `asm`.

```asm
section .text
global fuiLlamadaMasVeces

fuiLlamadaMasVeces:
    ;guardar registros usados en la pila
    push ebx
    push ecx

    ;obtener el ecx del ID de la tarea en edi
    mov ebx, [edi * TSS_SIZE + TSS_BASE_ADDR]  ;dirección de la TSS de la tarea con ID en edi
    mov ecx, [ebx + OFFSET_ECX]                
    ;leer el UTC (ecx)

    ;obtener el UTC de la tarea actual
    mov ebx, [TSS_ACTUAL + OFFSET_ECX]         ;dirección de la TSS actual
    cmp ebx, ecx                             
    ;comparar UTCs
    jl .menor                         
    mov eax, 0
    pop ecx
    pop ebx
    iret

    .menor:
        mov eax, 1
        pop ecx
        pop ebx
        iret
```    

### $(e)$ Pregunta extra: ¿tiene sentido a nivel sistema tener un registro de propósito general reservado para guardar el UTC? ¿De qué otra manera podría solucionarse?

Reservar un registro de propósito general, como `ecx`, para almacenar el **UTC** (Unreal Time Clock) no es ideal.

- `ecx` es un registro de propósito general en la arquitectura x86 y se utiliza para una variedad de operaciones. Reservarlo para el UTC reduce la flexibilidad de las tareas, que ya no pueden usar `ecx` libremente.
- Además, esto obliga a que el sistema mantenga el valor de UTC en `ecx` constantemente actualizado y sincronizado, lo cual es una carga adicional para el manejo de contexto y puede ser propenso a errores si una tarea necesita modificar temporalmente `ecx`.

Alternativas:

**Almacenarlo en la TSS de Cada Tarea**:
- La **TSS (Task State Segment)** de cada tarea ya está diseñada para almacenar información específica de la tarea, como el puntero de pila (`ESP`), puntero de instrucción (`EIP`), y registros de propósito general (incluyendo `ecx`). 
- Al guardar el UTC como un campo separado en la TSS, cada tarea puede tener su propio valor de UTC, manteniendo la persistencia a través de los cambios de contexto. Además, esto libera `ecx` para uso general sin necesidad de sincronización adicional.
   
**Mantener el UTC en una Estructura de Datos de Software**:
- Otra opción es usar una **estructura de datos en memoria** dentro del espacio del kernel, donde se almacenen los UTCs de cada tarea. Esto podría ser un array, como `uint32_t utc[TASK_COUNT]`, donde `TASK_COUNT` es el número de tareas en el sistema.
- Cada vez que el scheduler realiza un cambio de contexto, puede acceder y actualizar esta estructura en lugar de depender de registros específicos. Además, este método permite una fácil lectura y manipulación de UTCs, especialmente para funciones como *fuiLlamadaMasVeces*.
   
**Usar un Segmento o Página Compartida**:
- En sistemas que implementan memoria compartida, se puede crear un segmento de memoria compartido donde cada tarea almacene su UTC. Esto simplifica la implementación de servicios que comparen o verifiquen el UTC entre tareas, ya que todas acceden al mismo espacio de memoria.
- Esto también permite que el sistema sea extensible: se pueden agregar datos adicionales por tarea sin necesidad de modificar los registros o la TSS.


---

## Ejercicio 2 - (50 puntos)

Por un lado tienen un sistema similar al utilizado en el taller de la materia y por el otro una colección de software originalmente diseñado para correr en nivel cero. 

Los programas de dicha colección de software utilizaban la instrucción HLT para apagar la computadora una vez habían terminado su trabajo.

Por razones obvias no podemos permitir esto en un sistema multitarea.

Se solicita adaptar el sistema implementado en los talleres para que se puedan utilizar estos programas en nivel de usuario y sin modificaciones. 

Cuando éstos intenten ejecutar `HLT` el sistema operativo debe interpretar esa acción como una solicitud de “fin de la tarea”.

$a.$ ¿Qué excepción ocurrirá cuando un proceso no privilegiado intente ejecutar `HLT`?

$b.$ ¿Cómo puede determinar que la instrucción que se quiso ejecutar es `HLT`?

$c.$ ¿Qué pasos debe seguir para “finalizar” un proceso?

$d.$ ¿Cómo determinará el próximo proceso a ejecutar?

$e.$ Describa los cambios que debe realizar a las estructuras del sistema para poder agregar el mecanismo solicitado.

$f.$ Escriba el pseudocódigo necesario para implementar el mecanismo.

Su pseudocódigo debe describir el detalle de las siguientes acciones:

* Atender la excepción y determinar si es necesario usar el nuevo mecanismo
* Finalizar el proceso que generó la excepción
* Abandonar el proceso finalizado saltando a uno todavía vivo
* Modificar el scheduler (de ser necesario) para que nunca ejecute procesos finalizados